'use strict';

(function (global, factory) {
  if (typeof exports === "object" && typeof module !== "undefined") {
    module.exports = factory();
  } else if (typeof define === "function" && define.amd) {
    define(factory);
  } else {
    global = typeof globalThis !== "undefined" ? globalThis : global || self;
    global.QrScanner = factory();
  }
})(this, function () {
  class QrScanner {
    constructor($video, onDecode, opt, legacyOnDecode, preferredCamera) {
      this._legacyCanvasSize = QrScanner.DEFAULT_CANVAS_SIZE;
      this._preferredCamera = "environment";
      this._maxScansPerSecond = 25;
      this._lastScanTimestamp = -1;
      this._destroyed = false;
      this._flashOn = false;
      this._paused = false;
      this._active = false;

      this.$video = $video;
      this.$canvas = document.createElement("canvas");

      if (opt && typeof opt === "object") {
        this._onDecode = onDecode;
      } else {
        if (opt || legacyOnDecode || preferredCamera) {
          console.warn(
            "You're using a deprecated version of the QrScanner constructor which will be removed in the future"
          );
        } else {
          console.warn(
            "Note that the type of the scan result passed to onDecode will change in the future. To already switch to the new api today, you can pass returnDetailedScanResult: true."
          );
        }
        this._legacyOnDecode = onDecode;
      }

      // Process options if provided as object
      if (typeof opt === "object") {
        this._onDecodeError =
          opt.onDecodeError || (typeof opt === "function" ? opt : this._onDecodeError);
        this._calculateScanRegion =
          opt.calculateScanRegion || (typeof legacyOnDecode === "function" ? legacyOnDecode : this._calculateScanRegion);
        this._preferredCamera = opt.preferredCamera || preferredCamera || this._preferredCamera;
      }
      this._legacyCanvasSize =
        typeof opt === "number" ? opt : typeof legacyOnDecode === "number" ? legacyOnDecode : this._legacyCanvasSize;
      if (opt && typeof opt === "object") {
        this._maxScansPerSecond = opt.maxScansPerSecond || this._maxScansPerSecond;
      }

      this._onPlay = this._onPlay.bind(this);
      this._onLoadedMetaData = this._onLoadedMetaData.bind(this);
      this._onVisibilityChange = this._onVisibilityChange.bind(this);
      this._updateOverlay = this._updateOverlay.bind(this);

      $video.disablePictureInPicture = true;
      $video.playsInline = true;
      $video.muted = true;
      let wasHidden = false;
      if ($video.hidden) {
        $video.hidden = false;
        wasHidden = true;
      }
      if (!document.body.contains($video)) {
        document.body.appendChild($video);
        wasHidden = true;
      }
      let parent = $video.parentElement;
      if (opt && (opt.highlightScanRegion || opt.highlightCodeOutline)) {
        let useOverlay = !!opt.overlay;
        this.$overlay = opt.overlay || document.createElement("div");
        const overlayStyle = this.$overlay.style;
        overlayStyle.position = "absolute";
        overlayStyle.display = "none";
        overlayStyle.pointerEvents = "none";
        this.$overlay.classList.add("scan-region-highlight");

        if (!useOverlay && opt.highlightScanRegion) {
          this.$overlay.innerHTML =
            '<svg class="scan-region-highlight-svg" viewBox="0 0 238 238" preserveAspectRatio="none" style="position:absolute;width:100%;height:100%;left:0;top:0;fill:none;stroke:#e9b213;stroke-width:4;stroke-linecap:round;stroke-linejoin:round"><path d="M31 2H10a8 8 0 0 0-8 8v21M207 2h21a8 8 0 0 1 8 8v21m0 176v21a8 8 0 0 1-8 8h-21m-176 0H10a8 8 0 0 1-8-8v-21"/></svg>';
          try {
            this.$overlay.firstElementChild.animate(
              { transform: ["scale(.98)", "scale(1.01)"] },
              { duration: 400, iterations: Infinity, direction: "alternate", easing: "ease-in-out" }
            );
          } catch (e) {}
          parent.insertBefore(this.$overlay, $video.nextSibling);
        }
        if (opt.highlightCodeOutline) {
          this.$overlay.insertAdjacentHTML(
            "beforeend",
            '<svg class="code-outline-highlight" preserveAspectRatio="none" style="display:none;width:100%;height:100%;fill:none;stroke:#e9b213;stroke-width:5;stroke-dasharray:25;stroke-linecap:round;stroke-linejoin:round"><polygon/></svg>'
          );
          this.$codeOutlineHighlight = this.$overlay.lastElementChild;
        }
      }
      this._scanRegion = this._calculateScanRegion($video);
      requestAnimationFrame(() => {
        const computedStyle = window.getComputedStyle($video);
        if (computedStyle.display === "none") {
          $video.style.setProperty("display", "block", "important");
          wasHidden = true;
        }
        if (computedStyle.visibility !== "visible") {
          $video.style.setProperty("visibility", "visible", "important");
          wasHidden = true;
        }
        if (wasHidden) {
          console.warn(
            "QrScanner has overwritten the video hiding style to avoid Safari stopping the playback."
          );
          $video.style.opacity = "0";
          $video.style.width = "0";
          $video.style.height = "0";
          if (this.$overlay && this.$overlay.parentElement) {
            this.$overlay.parentElement.removeChild(this.$overlay);
          }
          delete this.$overlay;
          delete this.$codeOutlineHighlight;
        }
        if (this.$overlay) {
          this._updateOverlay();
        }
      });

      $video.addEventListener("play", this._onPlay);
      $video.addEventListener("loadedmetadata", this._onLoadedMetaData);
      document.addEventListener("visibilitychange", this._onVisibilityChange);
      window.addEventListener("resize", this._updateOverlay);

      this._qrEnginePromise = QrScanner.createQrEngine();
    }

    static set WORKER_PATH(path) {
      console.warn(
        "Setting QrScanner.WORKER_PATH is not required and not supported anymore. Have a look at the README for new setup instructions."
      );
    }

    static async hasCamera() {
      try {
        return !!(await QrScanner.listCameras(false)).length;
      } catch (e) {
        return false;
      }
    }

    static async listCameras(facingModeLabel = false) {
      if (!navigator.mediaDevices) return [];
      const getVideoInputs = async () =>
        (await navigator.mediaDevices.enumerateDevices()).filter(device => device.kind === "videoinput");
      let stream;
      try {
        if (facingModeLabel && (await getVideoInputs()).every(device => !device.label)) {
          stream = await navigator.mediaDevices.getUserMedia({ audio: false, video: true });
        }
      } catch (e) {}
      try {
        return (await getVideoInputs()).map((device, index) => ({
          id: device.deviceId,
          label: device.label || (index === 0 ? "Default Camera" : `Camera ${index + 1}`)
        }));
      } finally {
        if (stream) {
          console.warn(
            "Call listCameras after successfully starting a QR scanner to avoid creating a temporary video stream"
          );
          QrScanner._stopVideoStream(stream);
        }
      }
    }

    async hasFlash() {
      let stream;
      try {
        if (this.$video.srcObject) {
          if (!(this.$video.srcObject instanceof MediaStream)) return false;
          stream = this.$video.srcObject;
        } else {
          stream = (await this._getCameraStream()).stream;
        }
        return "torch" in stream.getVideoTracks()[0].getSettings();
      } catch (e) {
        return false;
      } finally {
        if (stream && stream !== this.$video.srcObject) {
          console.warn(
            "Call hasFlash after successfully starting the scanner to avoid creating a temporary video stream"
          );
          QrScanner._stopVideoStream(stream);
        }
      }
    }

    isFlashOn() {
      return this._flashOn;
    }

    async toggleFlash() {
      if (this._flashOn) {
        await this.turnFlashOff();
      } else {
        await this.turnFlashOn();
      }
    }

    async turnFlashOn() {
      if (!this._flashOn && !this._destroyed) {
        this._flashOn = true;
        if (this._active && !this._paused) {
          try {
            if (!await this.hasFlash()) throw "No flash available";
            await this.$video.srcObject.getVideoTracks()[0].applyConstraints({
              advanced: [{ torch: true }]
            });
          } catch (e) {
            this._flashOn = false;
            throw e;
          }
        }
      }
    }

    async turnFlashOff() {
      if (this._flashOn) {
        this._flashOn = false;
        await this._restartVideoStream();
      }
    }

    destroy() {
      this.$video.removeEventListener("loadedmetadata", this._onLoadedMetaData);
      this.$video.removeEventListener("play", this._onPlay);
      document.removeEventListener("visibilitychange", this._onVisibilityChange);
      window.removeEventListener("resize", this._updateOverlay);
      this._destroyed = true;
      this._flashOn = false;
      this.stop();
      QrScanner._postWorkerMessage(this._qrEnginePromise, "close");
    }

    async start() {
      if (this._destroyed)
        throw Error("The QR scanner can not be started as it had been destroyed.");
      if (!this._active || this._paused) {
        if (
          window.location.protocol !== "https:" &&
          console.warn("The camera stream is only accessible if the page is transferred via https.")
        );
        this._active = true;
        if (!document.hidden) {
          this._paused = false;
          if (this.$video.srcObject) {
            await this.$video.play();
          } else {
            try {
              const { stream, facingMode } = await this._getCameraStream();
              if (!this._active || this._paused) {
                QrScanner._stopVideoStream(stream);
              } else {
                this._setVideoMirror(facingMode);
                this.$video.srcObject = stream;
                await this.$video.play();
                if (this._flashOn) {
                  this._flashOn = false;
                  this.turnFlashOn().catch(() => {});
                }
              }
            } catch (e) {
              if (!this._paused) {
                this._active = false;
                throw e;
              }
            }
          }
        }
      }
    }

    stop() {
      this.pause();
      this._active = false;
    }

    async pause(force = false) {
      this._paused = true;
      if (!this._active) return true;
      this.$video.pause();
      if (this.$overlay) {
        this.$overlay.style.display = "none";
      }
      const stopStream = () => {
        if (this.$video.srcObject instanceof MediaStream) {
          QrScanner._stopVideoStream(this.$video.srcObject);
          this.$video.srcObject = null;
        }
      };
      if (force) {
        stopStream();
        return true;
      }
      await new Promise(resolve => setTimeout(resolve, 300));
      if (!this._paused) return false;
      stopStream();
      return true;
    }

    async setCamera(camera) {
      if (camera !== this._preferredCamera) {
        this._preferredCamera = camera;
        await this._restartVideoStream();
      }
    }

    static async scanImage(image, optsOrScanRegion, qrEngine, canvas, disallowCanvasResizing = false, alsoTryWithoutScanRegion = false) {
      console.log('Starting scanImage with:', { image, optsOrScanRegion });
      let scanRegion, providedEngine, providedCanvas, disableResize = false;
      let returnDetailed = false;
      if (
        optsOrScanRegion &&
        ("scanRegion" in optsOrScanRegion ||
          "qrEngine" in optsOrScanRegion ||
          "canvas" in optsOrScanRegion ||
          "disallowCanvasResizing" in optsOrScanRegion ||
          "alsoTryWithoutScanRegion" in optsOrScanRegion ||
          "returnDetailedScanResult" in optsOrScanRegion)
      ) {
        scanRegion = optsOrScanRegion.scanRegion;
        providedEngine = optsOrScanRegion.qrEngine;
        providedCanvas = optsOrScanRegion.canvas;
        disableResize = optsOrScanRegion.disallowCanvasResizing || false;
        alsoTryWithoutScanRegion = optsOrScanRegion.alsoTryWithoutScanRegion || false;
        returnDetailed = true;
      } else if (optsOrScanRegion || qrEngine || canvas || disallowCanvasResizing || alsoTryWithoutScanRegion) {
        console.warn("You're using a deprecated api for scanImage which will be removed in the future.");
      } else {
        console.warn(
          "Note that the return type of scanImage will change in the future. To already switch to the new api today, you can pass returnDetailedScanResult: true."
        );
      }
      let useWorker = !!providedEngine;
      try {
        let imageElement;
        console.log('Loading image and creating QR engine...');
        [providedEngine, imageElement] = await Promise.all([
          providedEngine || QrScanner.createQrEngine(), 
          QrScanner._loadImage(image)
        ]);
        console.log('Image loaded and engine created:', { imageElement, engineType: providedEngine.constructor.name });

        let ctx;
        [providedCanvas, ctx] = QrScanner._drawToCanvas(imageElement, scanRegion, providedCanvas, disableResize);
        console.log('Image drawn to canvas');

        let result;
        if (providedEngine instanceof Worker) {
          let worker = providedEngine;
          if (!useWorker) {
            QrScanner._postWorkerMessageSync(worker, "inversionMode", "both");
          }
          result = await new Promise((resolve, reject) => {
            let timeoutId = -1;
            const messageHandler = event => {
              console.log('Received detailed QR code data:', {
                data: event.data.data,
                version: event.data.version,
                errorCorrectionLevel: event.data.errorCorrectionLevel,
                maskPattern: event.data.maskPattern,
                cornerPoints: event.data.cornerPoints,
                bytes: event.data.bytes
              });
              
              if (event.data.id === timeoutId) {
                worker.removeEventListener("message", messageHandler);
                worker.removeEventListener("error", errorHandler);
                clearTimeout(timeoutId);
                if (event.data.data !== null) {
                  const result = {
                    data: event.data.data,
                    cornerPoints: QrScanner._convertPoints(event.data.cornerPoints, scanRegion),
                    bytes: event.data.bytes,
                    version: event.data.version,
                    errorCorrectionLevel: event.data.errorCorrectionLevel,
                    maskPattern: event.data.maskPattern,
                    rawData: event.data.rawData,
                    qrMatrix: event.data.qrMatrix,
                    decoding_data: worker.getDecodingData()
                  };
                  console.log('Worker passing result with matrix:', result);
                  resolve(result);
                } else {
                  reject(QrScanner.NO_QR_CODE_FOUND);
                }
              }
            };
            const errorHandler = errorEvent => {
              worker.removeEventListener("message", messageHandler);
              worker.removeEventListener("error", errorHandler);
              clearTimeout(timeoutId);
              reject("Scanner error: " + (errorEvent ? errorEvent.message || errorEvent : "Unknown Error"));
            };
            worker.addEventListener("message", messageHandler);
            worker.addEventListener("error", errorHandler);
            timeoutId = setTimeout(() => errorHandler("timeout"), 10000);
            const imageData = ctx.getImageData(0, 0, providedCanvas.width, providedCanvas.height);
            timeoutId = QrScanner._postWorkerMessageSync(worker, "decode", imageData, [imageData.data.buffer]);
          });
        } else {
          console.log('UMD - Using BarcodeDetector API');
          result = await Promise.race([
            new Promise((resolve, reject) => window.setTimeout(() => reject("Scanner error: timeout"), 10000)),
            (async () => {
              try {
                const detections = await providedEngine.detect(providedCanvas);
                console.log('BarcodeDetector detections:', detections);
                if (!detections[0]) throw QrScanner.NO_QR_CODE_FOUND;
                return {
                  data: detections[0].rawValue,
                  cornerPoints: QrScanner._convertPoints(detections[0].cornerPoints, scanRegion),
                  bytes: detections[0].rawValue.split("").map(ch => ch.charCodeAt(0))
                };
              } catch (err) {
                console.error('BarcodeDetector error:', err);
                const errMsg = err.message || err;
                if (/not implemented|service unavailable/.test(errMsg)) {
                  QrScanner._disableBarcodeDetector = true;
                  return QrScanner.scanImage(image, { 
                    scanRegion, 
                    canvas: providedCanvas, 
                    disallowCanvasResizing: disableResize, 
                    alsoTryWithoutScanRegion 
                  });
                }
                throw `Scanner error: ${errMsg}`;
              }
            })()
          ]);
        }
        console.log('Scan completed with result:', result);
        return returnDetailed ? result : result.data;
      } catch (err) {
        if (!scanRegion || !alsoTryWithoutScanRegion) throw err;
        let fallbackResult = await QrScanner.scanImage(image, { qrEngine: providedEngine, canvas: providedCanvas, disallowCanvasResizing: disableResize });
        return returnDetailed ? fallbackResult : fallbackResult.data;
      } finally {
        if (!useWorker) QrScanner._postWorkerMessage(providedEngine, "close");
      }
    }

    setGrayscaleWeights(red, green, blue, useIntegerApproximation = true) {
      QrScanner._postWorkerMessage(this._qrEnginePromise, "grayscaleWeights", { red, green, blue, useIntegerApproximation });
    }

    setInversionMode(mode) {
      QrScanner._postWorkerMessage(this._qrEnginePromise, "inversionMode", mode);
    }

    

    static async createQrEngine(workerPath) {
      console.log('Creating QR Engine...');
      QrScanner._disableBarcodeDetector = true;
      
      try {
        const zxingResponse = await fetch('https://unpkg.com/@zxing/library@latest/umd/index.min.js');
        const zxingCode = await zxingResponse.text();
        const workerCode = `
            // Initialize worker logs array
            let workerLogs = [];
            let decodingSteps = [];
            
            // Override console.log to post messages back to main thread
            const originalConsole = {
                log: console.log,
                error: console.error,
                warn: console.warn
            };
            
            console.log = (...args) => {
                workerLogs.push({
                    type: 'log',
                    timestamp: Date.now(),
                    data: args
                });
                self.postMessage({ type: 'log', data: args });
                originalConsole.log(...args);
            };
            
            console.error = (...args) => {
                workerLogs.push({
                    type: 'error',
                    timestamp: Date.now(),
                    data: args
                });
                self.postMessage({ type: 'error', data: args });
                originalConsole.error(...args);
            };
            
            ${zxingCode}
            
            function bytesToBinary(bytes) {
                let binaryString = '';
                for (let byte of bytes) {
                    // Convert each byte to its binary representation
                    let binary = byte.toString(2);
                    // Pad with leading zeros to ensure 8 bits
                    binary = binary.padStart(8, '0');
                    binaryString += binary;
                }
                return binaryString;
            }
            
            function decodeQR(imageData) {
                try {
                    const canvas = new OffscreenCanvas(imageData.width, imageData.height);
                    const ctx = canvas.getContext('2d');
                    
                    function preprocessImage(imageData) {
                        const data = imageData.data;
                        const width = imageData.width;
                        const height = imageData.height;
                        const processed = new Uint8ClampedArray(data.length);
                        
                        // Match html5-qrcode's approach:
                        // 1. Use grayscale conversion weights from html5-qrcode
                        const RED_WEIGHT = 0.2126;
                        const GREEN_WEIGHT = 0.7152;
                        const BLUE_WEIGHT = 0.0722;
                        
                        // First pass - calculate average brightness
                        let totalBrightness = 0;
                        let pixelCount = 0;
                        
                        for (let y = 0; y < height; y++) {
                            for (let x = 0; x < width; x++) {
                                const idx = (y * width + x) * 4;
                                const gray = (data[idx] * RED_WEIGHT + 
                                            data[idx + 1] * GREEN_WEIGHT + 
                                            data[idx + 2] * BLUE_WEIGHT);
                                totalBrightness += gray;
                                pixelCount++;
                            }
                        }
                        
                        // Calculate adaptive threshold
                        const avgBrightness = totalBrightness / pixelCount;
                        const threshold = avgBrightness * 0.95; // Slightly more aggressive threshold
                        
                        // Second pass - apply threshold and handle circular modules
                        for (let y = 0; y < height; y++) {
                            for (let x = 0; x < width; x++) {
                                const idx = (y * width + x) * 4;
                                const gray = (data[idx] * RED_WEIGHT + 
                                            data[idx + 1] * GREEN_WEIGHT + 
                                            data[idx + 2] * BLUE_WEIGHT);
                                
                                // Use adaptive threshold
                                const value = gray < threshold ? 0 : 255;
                                
                                processed[idx] = value;
                                processed[idx + 1] = value;
                                processed[idx + 2] = value;
                                processed[idx + 3] = 255;
                            }
                        }
                        
                        return new ImageData(processed, width, height);
                    }

                    // Apply preprocessing
                    const processedImageData = preprocessImage(imageData);
                    ctx.putImageData(processedImageData, 0, 0);

                    // Match html5-qrcode's ZXing configuration
                    const hints = new Map();
                    hints.set(ZXing.DecodeHintType.POSSIBLE_FORMATS, [ZXing.BarcodeFormat.QR_CODE]);
                    hints.set(ZXing.DecodeHintType.TRY_HARDER, true);
                    hints.set(ZXing.DecodeHintType.PURE_BARCODE, false);
                    hints.set(ZXing.DecodeHintType.CHARACTER_SET, 'UTF-8');
                    hints.set(ZXing.DecodeHintType.ALSO_INVERTED, true);
                    
                    const reader = new ZXing.MultiFormatReader();
                    reader.setHints(hints);

            
                    const luminanceSource = new ZXing.HTMLCanvasElementLuminanceSource(canvas);
                    const binarizer = new ZXing.HybridBinarizer(luminanceSource);
                    const bitmap = new ZXing.BinaryBitmap(binarizer);
                    const result = reader.decode(bitmap);
                    // Debug log to see what's available
                    console.log('ZXing result:', {
                        properties: Object.keys(result),
                        methods: Object.getOwnPropertyNames(Object.getPrototypeOf(result)),
                        data: result.data,
                        format: result.format,
                        numBits: result.numBits,
                        // Add any other properties we find
                    });

                    // Extract all possible data
                    const rawBytes = Array.from(result.rawBytes || []);
                    const processedBytes = Array.from(result.resultMetadata?.get(0)?.value?.[0] || []);
                    const binaryString = rawBytes.map(byte => byte.toString(2).padStart(8, '0')).join('');
                                        // Parse encoding mode and message length from raw bytes
                    const firstByte = rawBytes[0];
                    const encodingMode = firstByte >> 4; // First 4 bits
                    

                    // Extract matrix from bitmap before decoding
                    const blackMatrix = bitmap.getBlackMatrix();
                    const width = blackMatrix.getWidth();
                    const height = blackMatrix.getHeight();
                    
                    // Convert to 2D array
                    const bitmapMatrix = [];
                    for (let y = 0; y < height; y++) {
                        const row = [];
                        for (let x = 0; x < width; x++) {
                            // ZXing uses true for black pixels, we'll convert to 1/0
                            row.push(blackMatrix.get(x, y) ? 1 : 0);
                        }
                        bitmapMatrix.push(row);
                    }


                    //---------[DETECTOR BITS]------------------------------------------------------           
                    console.log('=== Starting QR Detection ===');
                    
                    // Create QR Reader
                    const qrReader = new ZXing.QRCodeReader();
                    
                    // Get detector result from the bitmap
                    const detectorResult = new ZXing.DetectorResult(
                        blackMatrix,
                        [
                            new ZXing.ResultPoint(0, 0),  // top-left
                            new ZXing.ResultPoint(blackMatrix.width - 1, 0),  // top-right
                            new ZXing.ResultPoint(0, blackMatrix.height - 1)  // bottom-left
                        ]
                    );
                    
                    //console.log('=== Detector Results ===');
                    //console.log('DetectorResult properties:', Object.getOwnPropertyNames(detectorResult));
                    //console.log(detectorResult.bits)

                    // Get the bits matrix
                    const detectorBits = detectorResult.bits
                    const detectorQrMatrix = [];

                    if (detectorBits) {
                        const dimension = detectorBits.getWidth(); // Should be equal to height for QR
                        
                        
                        // Create our binary matrix from the detected bits
                        for (let y = 0; y < dimension; y++) {
                            const row = [];
                            for (let x = 0; x < dimension; x++) {
                                row.push(detectorBits.get(x, y) ? 1 : 0);
                            }
                            detectorQrMatrix.push(row);
                        }
                        

                    }

                    //---------[TRANSFORM]------------------------------------------------------                               
                    // Create QR Reader and get detector
                    // Get the finder patterns (three corners) from the result
                    const resultPoints = result.getResultPoints();

                    // Calculate the expected dimension from the QR version
                    const version = 1;
                    const dimension = 17 + 4 * version; // QR code dimension formula
                    

                    //---------[Corner point extraction (unusued, unsorted)]------------------------------------------------------                               

                    // First get the centers of the finder patterns
                    // const bottomLeftCenterPre = resultPoints[0]; 
                    // const topLeftCenterPre = resultPoints[1];      
                    // const topRightCenterPre = resultPoints[2];     

                    //---------[Corner Point Sorting]------------------------------------------------------                               
                    // Sort finder patterns into correct positions
                    const sortFinderPatterns = (points) => {
                        if (!points || points.length !== 3) return points;
                        
                        // Calculate angle between three points using dot product
                        const calculateAngle = (p1, p2, p3) => {
                            const v1 = { x: p1.x - p2.x, y: p1.y - p2.y };
                            const v2 = { x: p3.x - p2.x, y: p3.y - p2.y };
                            const dot = v1.x * v2.x + v1.y * v2.y;
                            const mag1 = Math.sqrt(v1.x * v1.x + v1.y * v1.y);
                            const mag2 = Math.sqrt(v2.x * v2.x + v2.y * v2.y);
                            return Math.acos(dot / (mag1 * mag2)) * (180 / Math.PI);
                        };

                        // Calculate angles at each point
                        const angles = [
                            { index: 0, angle: calculateAngle(points[1], points[0], points[2]) },
                            { index: 1, angle: calculateAngle(points[0], points[1], points[2]) },
                            { index: 2, angle: calculateAngle(points[0], points[2], points[1]) }
                        ];

                        // Find the corner point (closest to 90 degrees)
                        const cornerIndex = angles.reduce((closest, current, i) => 
                            Math.abs(current.angle - 90) < Math.abs(angles[closest].angle - 90) ? i : closest
                        , 0);
                        
                        // Get the other two points
                        const otherIndices = [0, 1, 2].filter(i => i !== cornerIndex);
                        const corner = points[cornerIndex];
                        const other1 = points[otherIndices[0]];
                        const other2 = points[otherIndices[1]];

                        // Calculate cross product to determine clockwise ordering
                        const crossProduct = (p1, p2, p3) => {
                            return (p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x);
                        };

                        // If cross product is positive, other1 is clockwise from other2
                        const isClockwise = crossProduct(corner, other1, other2) > 0;
                        const [bottomLeftIndex, topRightIndex] = isClockwise ? 
                            [otherIndices[1], otherIndices[0]] : 
                            [otherIndices[0], otherIndices[1]];

                        // Return points in order: bottom-left, top-left (corner), top-right
                        return [
                            points[bottomLeftIndex],
                            points[cornerIndex],
                            points[topRightIndex]
                        ];
                    };
                    // Sort the finder patterns
                    const [bottomLeftCenter, topLeftCenter, topRightCenter] = sortFinderPatterns(resultPoints);




                    //---------[Calculate angle rotation and corner offsets]------------------------------------------------------                               
                    // Use the estimated module size from the finder pattern
                    const moduleSize = resultPoints[0].estimatedModuleSize;

                    // Calculate rotation angle from the finder patterns
                    const angle = Math.atan2(
                        topRightCenter.y - topLeftCenter.y,
                        topRightCenter.x - topLeftCenter.x
                    );
                    
                    // Finder patterns are 7x7 modules, so adjust by 3.5 modules to get to the corner
                    const finderPatternOffset = 3.5 * moduleSize;

                    // Helper function to calculate rotated offset
                    const getRotatedOffset = (centerPoint, xOffset, yOffset) => ({
                        x: centerPoint.x + (xOffset * Math.cos(angle) - yOffset * Math.sin(angle)),
                        y: centerPoint.y + (xOffset * Math.sin(angle) + yOffset * Math.cos(angle))
                    });

                    // Calculate actual corners by applying rotated offsets from the centers
                    const topLeft = getRotatedOffset(topLeftCenter, -finderPatternOffset, -finderPatternOffset);
                    const topRight = getRotatedOffset(topRightCenter, finderPatternOffset, -finderPatternOffset);
                    const bottomLeft = getRotatedOffset(bottomLeftCenter, -finderPatternOffset, finderPatternOffset);
                    
                    // Calculate bottom right using the same rotation
                    const bottomRight = {
                        x: topRight.x + (bottomLeft.x - topLeft.x),
                        y: topRight.y + (bottomLeft.y - topLeft.y)
                    };


                    //---------[Transformation]------------------------------------------------------                               
                    // Create perspective transform with actual corners
                    const transform = ZXing.PerspectiveTransform.quadrilateralToQuadrilateral(
                        // Destination points (normalized grid)
                        0, 0,                        // top-left (normalized)
                        dimension, 0,                // top-right (normalized)
                        dimension, dimension,        // bottom-right (normalized)
                        0, dimension,                // bottom-left (normalized)
                        
                        // Source points (actual QR code corners)
                        topLeft.x, topLeft.y,           // actual top-left corner
                        topRight.x, topRight.y,         // actual top-right corner
                        bottomRight.x, bottomRight.y,   // actual bottom-right corner
                        bottomLeft.x, bottomLeft.y      // actual bottom-left corner

                    );
                    console.log(transform)
                    const sampledMatrix = [];
                    for (let y = 0; y < dimension; y++) {
                        const row = [];
                        for (let x = 0; x < dimension; x++) {
                            // Create source and destination arrays
                            const srcPoints = new Float32Array([x + 0.5, y + 0.5]); // normalized coordinates (0-21)
                            const dstPoints = new Float32Array(2);                   // will contain bitmap coordinates
                            
                            // Transform the point FROM normalized TO bitmap coordinates
                            transform.transformPoints(srcPoints, dstPoints);
                            
                            // Get the transformed coordinates (should now be in bitmap space)
                            const sourceX = Math.floor(srcPoints[0]);  // Should be around 65-205
                            const sourceY = Math.floor(srcPoints[1]);  // Should be around 65-205

                            // Sample from bitmap
                            if (sourceX >= 0 && sourceX < bitmapMatrix[0].length &&
                                sourceY >= 0 && sourceY < bitmapMatrix.length) {
                                row.push(bitmapMatrix[sourceY][sourceX]);
                            } else {
                                row.push(0);
                            }
                        }
                        sampledMatrix.push(row);
                    }

                    //---------[Encoding type extraction]------------------------------------------------------                               

                    // Get encoding name based on QR standard
                    const getEncodingName = (mode) => {
                        switch(mode) {
                            case 0x1: return 'Numeric';
                            case 0x2: return 'Alphanumeric';
                            case 0x4: return 'Byte';
                            case 0x8: return 'Kanji';
                            case 0x3: return 'Structured Append';
                            case 0x7: return 'ECI';
                            case 0x0: return 'End of Message';
                            default: return 'Unknown';
                        }
                    };

                    //---------[Extract format information]------------------------------------------------------                               
                    function extractFormatInfo(matrix) {
                        // First verify we have a valid QR code matrix
                        const size = matrix.length;
                        if (!matrix || size < 21) { // Version 1 is 21x21
                            throw new Error('Invalid matrix size: QR code must be at least 21x21');
                        }
                        
                        // Calculate version from size: (V-1)*4 + 21 = size
                        const version = (size - 21) / 4 + 1;
                        if (!Number.isInteger(version) || version < 1 || version > 40) {
                            throw new Error('Invalid QR code size');
                        }
                        
                        // Format info is stored in two locations (same for all versions):
                        // 1. Around top-left finder pattern
                        // 2. Split between bottom-left and top-right (for redundancy)
                        let formatBits1 = '';
                        let formatBits2 = '';
                        
                        // Read first copy (around top-left finder pattern)
                        // Horizontal part (left to right, excluding timing pattern at position 6)
                        for(let i = 0; i <= 8; i++) {
                            if(i === 6) continue; // Skip timing pattern
                            formatBits1 += matrix[8][i];
                        }
                        // Vertical part (top to bottom, excluding timing pattern at position 6)
                        for(let i = 7; i >= 0; i--) {
                            if(i === 6) continue; // Skip timing pattern
                            formatBits1 += matrix[i][8];
                        }
                        
                        // Read second copy (split between bottom-left and top-right)
                        // Bottom-left vertical part (bottom to top)
                        for(let i = size - 1; i >= size - 7; i--) {
                            formatBits2 += matrix[i][8];
                        }
                        // Top-right horizontal part (right to left)
                        for(let i = size - 8; i <= size - 1; i++) {
                            formatBits2 += matrix[8][i];
                        }
                        
                        // Convert binary strings to numbers
                        const formatInfo1 = parseInt(formatBits1, 2);
                        const formatInfo2 = parseInt(formatBits2, 2);
                                            
                        // XOR with mask pattern
                        const maskedFormatInfo1 = formatInfo1 ^ 0b101010000010010;
                        const maskedFormatInfo2 = formatInfo2 ^ 0b101010000010010;
                        
                        // Use the first copy by default, but if it seems invalid, try the second
                        let maskedFormatInfo = maskedFormatInfo1;
                        if ((maskedFormatInfo1 & 0x7) > 7) { // Invalid mask pattern
                            maskedFormatInfo = maskedFormatInfo2;
                        }
                        
                        // Extract error correction level (bits 14-13)
                        const errorCorrectionLevel = (maskedFormatInfo >> 13) & 0x3;
                        
                        // Extract mask pattern (bits 12-10)
                        const maskPattern = (maskedFormatInfo >> 10) & 0x7;
                        
                        return {
                            version: version,
                            rawBits: {
                                primary: formatBits1,
                                secondary: formatBits2
                            },
                            formatInfo: {
                                primary: formatInfo1,
                                secondary: formatInfo2
                            },
                            unmaskedFormatInfo: maskedFormatInfo,
                            maskPattern: maskPattern,
                            errorCorrectionLevel: ['M', 'L', 'H', 'Q'][errorCorrectionLevel],
                            debug: {
                                size: size,
                                formatBits1: formatBits1,
                                formatBits2: formatBits2,
                                maskedFormatInfo1: maskedFormatInfo1,
                                maskedFormatInfo2: maskedFormatInfo2,
                                binaryString: maskedFormatInfo.toString(2).padStart(15, '0')
                            }
                        };
                    }
                    
                    const extractedFormatInfo = extractFormatInfo(sampledMatrix)


                    //---------[Demask Matrix]------------------------------------------------------                               

                    // Add new function to unmask the matrix
                    function unmaskMatrix(matrix, maskPattern) {
                        const size = matrix.length;
                        const unmaskedMatrix = [];
                        
                        // Create mask function based on pattern
                        const getMaskBit = (i, j) => {
                            switch(maskPattern) {
                                case 0: return (i + j) % 2 === 0;
                                case 1: return i % 2 === 0;
                                case 2: return j % 3 === 0;
                                case 3: return (i + j) % 3 === 0;
                                case 4: return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 === 0;
                                case 5: return ((i * j) % 2) + ((i * j) % 3) === 0;
                                case 6: return (((i * j) % 2) + ((i * j) % 3)) % 2 === 0;
                                case 7: return (((i + j) % 2) + ((i * j) % 3)) % 2 === 0;
                                default: return false;
                            }
                        };
                        
                        // Apply unmask to data regions only
                        for(let i = 0; i < size; i++) {
                            unmaskedMatrix[i] = [];
                            for(let j = 0; j < size; j++) {
                                // Skip function patterns (finder patterns, timing patterns, etc.)
                                const isInFunctionPattern = (
                                    // Finder patterns (including separators)
                                    (i < 9 && j < 9) || // Top-left
                                    (i < 9 && j > size - 10) || // Top-right
                                    (i > size - 10 && j < 9) || // Bottom-left
                                    // Format information areas
                                    (i < 9 && j === 8) ||
                                    (i === 8 && j < 9) ||
                                    (i === 8 && j > size - 9) ||
                                    (i > size - 9 && j === 8) ||
                                    // Version information areas (if present)
                                    (size > 21 && ((i < 6 && j > size - 12) || (j < 6 && i > size - 12)))
                                );
                                
                                if (!isInFunctionPattern) {
                                    // XOR with mask pattern
                                    unmaskedMatrix[i][j] = matrix[i][j] ^ getMaskBit(i, j);
                                } else {
                                    // Keep function patterns unchanged
                                    unmaskedMatrix[i][j] = matrix[i][j];
                                }
                            }
                        }
                        
                        return unmaskedMatrix;
                    }

                    const unmaskedMatrix = unmaskMatrix(sampledMatrix, extractedFormatInfo.maskPattern)

                    //---------[Message length]------------------------------------------------------                               
                    const getLengthBits = (mode, version) => {
                        // For Version 1-9
                        switch(mode) {
                            case 0x1: return 10; // Numeric: 10 bits
                            case 0x2: return 9;  // Alphanumeric: 9 bits
                            case 0x4: return 8;  // Byte: 8 bits
                            case 0x8: return 8;  // Kanji: 8 bits
                            default: return 8;    // Default to 8 bits
                        }
                    };
                    
                    // Get length value from the appropriate number of bits
                    const lengthBits = getLengthBits(encodingMode, 1); // Assuming Version 1 for now
                    const lengthValue = ((firstByte & 0x0F) << (lengthBits - 4)) | // Remaining bits from first byte
                                      (rawBytes[1] >> (8 - (lengthBits - 4)));     // Bits from second byte
                    
                    const encodingInfo = {
                        mode: encodingMode,
                        modeName: getEncodingName(encodingMode),
                        length: lengthValue,
                        rawFirstBytes: [rawBytes[0], rawBytes[1]].map(b => b.toString(2).padStart(8, '0')),
                    };
                    

                    // Calculate where the message should end based on encoding and length
                    const messageBitsLength = (() => {
                        switch(encodingMode) {
                            case 0x1: return lengthValue * 10/3; // Numeric: 10 bits per 3 digits
                            case 0x2: return lengthValue * 11/2; // Alphanumeric: 11 bits per 2 chars
                            case 0x4: return lengthValue * 8;    // Byte: 8 bits per char
                            case 0x8: return lengthValue * 13;   // Kanji: 13 bits per char
                            default: return 0;
                        }
                    })();
                    // Get end position
                    const messageEndPosition = 4 + lengthBits + messageBitsLength;
                    
                    // Get bits and padding
                    const endBitsInfo = {
                        message: binaryString.slice(0, messageEndPosition),
                        terminator: binaryString.slice(messageEndPosition, messageEndPosition + 4),
                        padding: binaryString.slice(messageEndPosition + 4)
                    };
                    
                    console.log('End bits analysis:', endBitsInfo);
                    
                    //---------[Compile output results]------------------------------------------------------                               
                    const detailedResult = {
                        // Basic QR Data
                        data: result.text || result.getText(),
                        rawBinaryString: binaryString,
                        numBits: result.numBits,
                        terminatorBits: endBitsInfo.terminator, 
                        paddingBits: endBitsInfo.padding,
                        cornerPoints: result.resultPoints,
                        eccFormat: result.resultMetadata?.get(3), 
                        messageLength: lengthValue,
                        encodingMode: encodingMode, 
                        encodingModeName: encodingInfo.modeName, 
                        rawResult: result,
                        detectorBits:  detectorBits,
                        detectorResult:  detectorResult,
                        detectorQrMatrix:  detectorQrMatrix,
                        sampledMatrix: sampledMatrix,
                        unmaskedMatrix: unmaskedMatrix,
                        bitmapMatrix: bitmapMatrix,
                        format: result.format,
                        formatExtracted: extractedFormatInfo,
                        rawData: (function() {
                            try {
                                var matrix = binarizer.matrix;
                                if (!matrix) return null;
                                
                                var rect = matrix.getEnclosingRectangle();
                                if (!rect) return null;
                                
                                var left = rect[0],
                                    top = rect[1],
                                    qrWidth = rect[2],
                                    qrHeight = rect[3];
                                
                                var moduleSize = Math.floor(Math.min(qrWidth, qrHeight) / 21);
                                var qrMatrix = [];
                                
                                // Multi-point sampling for each module
                                function sampleModule(centerX, centerY) {
                                    var samples = [
                                        // Center point
                                        matrix.get(centerX, centerY),
                                        // Sample points in a + pattern
                                        matrix.get(centerX - 1, centerY),
                                        matrix.get(centerX + 1, centerY),
                                        matrix.get(centerX, centerY - 1),
                                        matrix.get(centerX, centerY + 1)
                                    ];
                                    
                                    // Count black pixels
                                    var blackCount = samples.filter(Boolean).length;
                                    // Return 1 if majority of samples are black
                                    return blackCount > 2 ? 1 : 0;
                                }
                                
                                for (var y = 0; y < 21; y++) {
                                    qrMatrix[y] = [];
                                    for (var x = 0; x < 21; x++) {
                                        var centerX = left + Math.floor((x + 0.5) * moduleSize);
                                        var centerY = top + Math.floor((y + 0.5) * moduleSize);
                                        qrMatrix[y][x] = sampleModule(centerX, centerY);
                                    }
                                }
                                
                                var resultData = {
                                    matrix: qrMatrix,
                                    dims: {
                                        moduleSize: moduleSize,
                                        width: qrWidth,
                                        height: qrHeight,
                                        left: left,
                                        top: top
                                    },
                                    version: (sampledMatrix.length - 17) / 4
                                };
                                
                                result.qrMatrix = qrMatrix;
                                result.rawData = resultData;
                                
                                return resultData;
                            } catch (e) {
                                return null;
                            }
                        })(),
                        // Corrected Data
                        correctedBytes2Binary: result.resultMetadata.get(2)?.[0] ? 
                            Array.from(result.resultMetadata.get(2)[0])
                                .map(byte => byte.toString(2).padStart(8, '0'))
                                .join('') : null,
                        rawBytes: rawBytes,
                        correctedBytes: result.resultMetadata.get(2)?.[0]
                    };

                    return detailedResult;
                } catch (e) {
                    console.error('Decoding error:', e.message);
                    return null;
                }
            }

            // Add worker message handler to include debug data
            self.onmessage = function(e) {
                const {id, type, data} = e.data;
                console.log('Worker received message:', type);
                
                if (type === 'decode') {
                    const startTime = performance.now();
                    const result = decodeQR(data);
                    const endTime = performance.now();
                    
                    // Include all debug information in the response
                    self.postMessage({
                        id,
                        type: 'result',
                        ...result,
                        debugData: {
                            workerLogs: workerLogs,
                            decodingSteps: decodingSteps,
                            timing: endTime - startTime
                        }
                    });
                    
                    // Clear logs after sending
                    workerLogs = [];
                    decodingSteps = [];
                }
            };
        `;
        
        const blob = new Blob([workerCode], { type: 'application/javascript' });
        const worker = new Worker(URL.createObjectURL(blob));
        
        let decodingDataStore;
        
        // Handle worker messages including logs
        worker.onmessage = (e) => {
            if (e.data.type === 'log') {
                console.log('Worker message:', ...e.data.data);
            } else if (e.data.type === 'error') {
                console.error('Worker:', ...e.data.data);
            } else {
                console.log('Worker result:', e.data);
                const decoding_data = e.data;
                decodingDataStore = decoding_data;
                worker.getDecodingData = () => decodingDataStore;
            }
        };
        
        worker.onerror = (error) => {
            console.error('Worker error:', error);
        };
        
        return worker;
      } catch (error) {
        console.error('Error creating QR Engine:', error);
        throw error;
      }
    }

    _onPlay() {
      this._scanRegion = this._calculateScanRegion(this.$video);
      this._updateOverlay();
      if (this.$overlay) {
        this.$overlay.style.display = "";
      }
      this._scanFrame();
    }

    _onLoadedMetaData() {
      this._scanRegion = this._calculateScanRegion(this.$video);
      this._updateOverlay();
    }

    _onVisibilityChange() {
      if (document.hidden) {
        this.pause();
      } else if (this._active) {
        this.start();
      }
    }

    _calculateScanRegion(video) {
      const minDimension = Math.min(video.videoWidth, video.videoHeight);
      const size = Math.round((2 / 3) * minDimension);
      return {
        x: Math.round((video.videoWidth - size) / 2),
        y: Math.round((video.videoHeight - size) / 2),
        width: size,
        height: size,
        downScaledWidth: this._legacyCanvasSize,
        downScaledHeight: this._legacyCanvasSize
      };
    }

    _updateOverlay() {
      requestAnimationFrame(() => {
        if (this.$overlay) {
          const video = this.$video;
          const videoWidth = video.videoWidth;
          const videoHeight = video.videoHeight;
          const offsetWidth = video.offsetWidth;
          const offsetHeight = video.offsetHeight;
          const offsetLeft = video.offsetLeft;
          const offsetTop = video.offsetTop;
          const computedStyle = window.getComputedStyle(video);
          const objectFit = computedStyle.objectFit;
          const videoRatio = videoWidth / videoHeight;
          const elementRatio = offsetWidth / offsetHeight;
          let drawWidth, drawHeight;
          switch (objectFit) {
            case "none":
              drawWidth = videoWidth;
              drawHeight = videoHeight;
              break;
            case "fill":
              drawWidth = offsetWidth;
              drawHeight = offsetHeight;
              break;
            default:
              if (objectFit === "cover" ? videoRatio > elementRatio : videoRatio < elementRatio) {
                drawHeight = offsetHeight;
                drawWidth = drawHeight * videoRatio;
              } else {
                drawWidth = offsetWidth;
                drawHeight = drawWidth / videoRatio;
              }
              if (objectFit === "scale-down") {
                drawWidth = Math.min(drawWidth, videoWidth);
                drawHeight = Math.min(drawHeight, videoHeight);
              }
          }
          const objectPositions = computedStyle.objectPosition.split(" ").map((pos, index) => {
            const num = parseFloat(pos);
            return pos.endsWith("%")
              ? (index ? offsetHeight - drawHeight : offsetWidth - drawWidth) * num / 100
              : num;
          });
          const regionWidth = this._scanRegion.width || videoWidth;
          const regionHeight = this._scanRegion.height || videoHeight;
          const regionX = this._scanRegion.x || 0;
          const regionY = this._scanRegion.y || 0;
          const style = this.$overlay.style;
          style.width = `${(regionWidth / videoWidth) * drawWidth}px`;
          style.height = `${(regionHeight / videoHeight) * drawHeight}px`;
          style.top = `${offsetTop + objectPositions[1] + (regionY / videoHeight) * drawHeight}px`;
          const isMirrored = /scaleX\(-1\)/.test(video.style.transform);
          style.left = `${offsetLeft + (isMirrored ? offsetWidth - objectPositions[0] - drawWidth : objectPositions[0]) + (isMirrored ? videoWidth - regionX - regionWidth : regionX) / videoWidth * drawWidth}px`;
          style.transform = video.style.transform;
        }
      });
    }

    static _convertPoints(points, scanRegion) {
      if (!scanRegion) return points;
      const offsetX = scanRegion.x || 0;
      const offsetY = scanRegion.y || 0;
      const scaleX =
        scanRegion.width && scanRegion.downScaledWidth ? scanRegion.width / scanRegion.downScaledWidth : 1;
      const scaleY =
        scanRegion.height && scanRegion.downScaledHeight ? scanRegion.height / scanRegion.downScaledHeight : 1;
      for (let point of points) {
        point.x = point.x * scaleX + offsetX;
        point.y = point.y * scaleY + offsetY;
      }
      return points;
    }

    _scanFrame() {
      if (!this._active || this.$video.paused || this.$video.ended) {
        (("requestVideoFrameCallback" in this.$video
          ? this.$video.requestVideoFrameCallback.bind(this.$video)
          : requestAnimationFrame)(() => {
          this._scanFrame();
        }));
        return;
      }
      (("requestVideoFrameCallback" in this.$video
        ? this.$video.requestVideoFrameCallback.bind(this.$video)
        : requestAnimationFrame)(async () => {
        if (this.$video.readyState > 1) {
          const elapsed = Date.now() - this._lastScanTimestamp;
          const delay = 1000 / this._maxScansPerSecond;
          if (elapsed < delay) {
            await new Promise(resolve => setTimeout(resolve, delay - elapsed));
          }
          this._lastScanTimestamp = Date.now();
          try {
            const result = await QrScanner.scanImage(this.$video, {
              scanRegion: this._scanRegion,
              qrEngine: this._qrEnginePromise,
              canvas: this.$canvas
            });
            if (result) {
              if (this._onDecode) {
                this._onDecode(result);
              } else if (this._legacyOnDecode) {
                this._legacyOnDecode(result.data);
              }
              if (this.$codeOutlineHighlight) {
                clearTimeout(this._codeOutlineHighlightRemovalTimeout);
                this._codeOutlineHighlightRemovalTimeout = undefined;
                this.$codeOutlineHighlight.setAttribute(
                  "viewBox",
                  `${this._scanRegion.x || 0} ${this._scanRegion.y || 0} ${this._scanRegion.width || this.$video.videoWidth} ${this._scanRegion.height || this.$video.videoHeight}`
                );
                this.$codeOutlineHighlight.firstElementChild.setAttribute(
                  "points",
                  result.cornerPoints.map(({ x, y }) => `${x},${y}`).join(" ")
                );
                this.$codeOutlineHighlight.style.display = "";
              }
            } else if (this.$codeOutlineHighlight && !this._codeOutlineHighlightRemovalTimeout) {
              this._codeOutlineHighlightRemovalTimeout = setTimeout(() => {
                this.$codeOutlineHighlight.style.display = "none";
              }, 100);
            }
          } catch (e) {
            if (!this._active) return;
            this._onDecodeError(e);
          }
          this._scanFrame();
        }
      }));
    }

    _onDecodeError(error) {
      if (error !== QrScanner.NO_QR_CODE_FOUND) {
        console.log(error);
      }
    }

    async _getCameraStream() {
      if (!navigator.mediaDevices) throw "Camera not found.";
      const constraintKey = /^(environment|user)$/.test(this._preferredCamera) ? "facingMode" : "deviceId";
      const constraintsArray = [{ width: { min: 1024 } }, { width: { min: 768 } }, {}];
      const constraintsWithPreferred = constraintsArray.map(constraints =>
        Object.assign({}, constraints, { [constraintKey]: { exact: this._preferredCamera } })
      );
      for (let constraints of [...constraintsWithPreferred, ...constraintsArray]) {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ video: constraints, audio: false });
          const facingMode = this._getFacingMode(stream) || (constraints.facingMode ? this._preferredCamera : this._preferredCamera === "environment" ? "user" : "environment");
          return { stream, facingMode };
        } catch (e) {}
      }
      throw "Camera not found.";
    }

    async _restartVideoStream() {
      const wasPaused = this._paused;
      if (await this.pause(true) && !wasPaused && this._active) {
        await this.start();
      }
    }

    static _stopVideoStream(stream) {
      for (let track of stream.getTracks()) {
        track.stop();
        stream.removeTrack(track);
      }
    }

    _setVideoMirror(facingMode) {
      this.$video.style.transform = "scaleX(" + (facingMode === "user" ? -1 : 1) + ")";
    }

    _getFacingMode(stream) {
      const track = stream.getVideoTracks()[0];
      if (track) {
        if (/rear|back|environment/i.test(track.label)) return "environment";
        if (/front|user|face/i.test(track.label)) return "user";
      }
      return null;
    }

    static _drawToCanvas(source, scanRegion, canvas, disallowCanvasResizing = false) {
      canvas = canvas || document.createElement("canvas");
      const sx = scanRegion && scanRegion.x ? scanRegion.x : 0;
      const sy = scanRegion && scanRegion.y ? scanRegion.y : 0;
      const sWidth = scanRegion && scanRegion.width ? scanRegion.width : source.videoWidth || source.width;
      const sHeight = scanRegion && scanRegion.height ? scanRegion.height : source.videoHeight || source.height;
      if (!disallowCanvasResizing) {
        const dWidth = scanRegion && scanRegion.downScaledWidth ? scanRegion.downScaledWidth : sWidth;
        const dHeight = scanRegion && scanRegion.downScaledHeight ? scanRegion.downScaledHeight : sHeight;
        if (canvas.width !== dWidth) canvas.width = dWidth;
        if (canvas.height !== dHeight) canvas.height = dHeight;
      }
      const ctx = canvas.getContext("2d", { alpha: false });
      ctx.imageSmoothingEnabled = false;
      ctx.drawImage(source, sx, sy, sWidth, sHeight, 0, 0, canvas.width, canvas.height);
      return [canvas, ctx];
    }

    static async _loadImage(image) {
      if (image instanceof Image) {
        await QrScanner._awaitImageLoad(image);
        return image;
      }
      if (
        image instanceof HTMLVideoElement ||
        image instanceof HTMLCanvasElement ||
        image instanceof SVGImageElement ||
        ("OffscreenCanvas" in window && image instanceof OffscreenCanvas) ||
        ("ImageBitmap" in window && image instanceof ImageBitmap)
      ) {
        return image;
      }
      if (image instanceof File || image instanceof Blob || image instanceof URL || typeof image === "string") {
        const img = new Image();
        img.src = image instanceof File || image instanceof Blob ? URL.createObjectURL(image) : image.toString();
        try {
          await QrScanner._awaitImageLoad(img);
          return img;
        } finally {
          if (image instanceof File || image instanceof Blob) URL.revokeObjectURL(img.src);
        }
      }
      throw "Unsupported image type.";
    }

    static async _awaitImageLoad(img) {
      if (img.complete && img.naturalWidth !== 0) return;
      await new Promise((resolve, reject) => {
        const handler = event => {
          img.removeEventListener("load", handler);
          img.removeEventListener("error", handler);
          event instanceof ErrorEvent ? reject("Image load error") : resolve();
        };
        img.addEventListener("load", handler);
        img.addEventListener("error", handler);
      });
    }

    static async _postWorkerMessage(qrEnginePromise, type, data, transfer) {
      return QrScanner._postWorkerMessageSync(await qrEnginePromise, type, data, transfer);
    }

    static _postWorkerMessageSync(worker, type, data, transfer) {
      if (!(worker instanceof Worker)) return -1;
      const id = QrScanner._workerMessageId++;
      
      // Add message handler for worker debug messages
      worker.addEventListener('message', (event) => {
          if (event.data.type === 'log' || event.data.type === 'error') {
              // Store debug information to be included with scan results
              if (!worker.debugLogs) worker.debugLogs = [];
              worker.debugLogs.push({
                  type: event.data.type,
                  timestamp: Date.now(),
                  data: event.data.data
              });
          }
      });
      
      worker.postMessage({ id, type, data }, transfer);
      return id;
    }
  }

  QrScanner.DEFAULT_CANVAS_SIZE = 400;
  QrScanner.NO_QR_CODE_FOUND = "No QR code found";
  QrScanner._disableBarcodeDetector = false;
  QrScanner._workerMessageId = 0;

  return QrScanner;
});
//# sourceMappingURL=qr-scanner.umd.min.js.map


